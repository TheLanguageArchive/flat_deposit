<?php

use Drupal\media\MediaInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Session\AccountInterface;
use Drupal\views\ViewExecutable;
use Drupal\flat_permissions\NodeAccessService;

/**
 * Implements hook_node_view().
 */
function flat_permissions_node_view(array &$build, \Drupal\Core\Entity\EntityInterface $node, $display, $view_mode)
{
    // disable caching for islandora object view to ensure that access policies are evaluated
    if ($node->getType() == 'islandora_object' && $view_mode == 'full') {
        \Drupal::service('page_cache_kill_switch')->trigger();
        $build['#cache']['max-age'] = 0;
    }
}

/**
 * Implements hook_views_pre_render().
 */
function flat_permissions_views_pre_render(Drupal\views\ViewExecutable $view)
{
    // disable caching for top level collections view to ensure that access policies are evaluated
    if ($view->id() == 'top_level_collections') {
        \Drupal::service('page_cache_kill_switch')->trigger();
    }
}

/**
 * Provides access control for media. Policies are defined on the parent Repository Item, or higher in the collection hierarchy
 *
 * @param MediaInterface $media
 * @param string $operation
 * @param AccountInterface $account
 * @return AccessResult
 */
function flat_permissions_media_access(MediaInterface $media, $operation, AccountInterface $account)
{
    if ($operation == "view" || $operation == "download") {

        $referenced_entities = $media->get('field_media_of')->referencedEntities();
        $referenced_ids = [];

        foreach ($referenced_entities as $entity) {
            $referenced_ids[] = $entity->id();
        }

        $parent_nid = $referenced_ids[0]; // There should be only one, we don't support multiple parents
        // Fetch the access policy of the parent
        $manager = \Drupal::service('flat_permissions.permissions_manager');
        $policy = $manager->fetchAccessPolicy($parent_nid, 'read');

        if (!$policy) {
            // No policy on the direct parent, check further up the hierarchy
            $effective_policy = $manager->fetchEffectiveAccessPolicy($parent_nid, 'read');
            if ($effective_policy) {
                $policy = $effective_policy['policy'];
            }
        }

        if (!$policy) {
            // If there's no policy in the hierarchy (shouldn't really be the case), deny access
            return AccessResult::forbidden();
        }

        // First, check if there is an "all" rule that applies to all media within the hierarchy
        if (property_exists($policy, "all")) {
            $rule = $policy->all;
            if (property_exists($rule, "roles")) {
                $allowed_roles = $rule->roles;
                $user_roles = $account->getRoles();
                foreach ($user_roles as $user_role) {
                    if (in_array($user_role, $allowed_roles)) {
                        return AccessResult::allowed();
                    }
                }
            }
            if (property_exists($rule, "users")) {
                $allowed_users = $rule->users;
                if (in_array($account->id(), $allowed_users)) {
                    return AccessResult::allowed();
                }
            }
        }

        // Second, check if there are "mime" rules that apply to specific mime types
        if (property_exists($policy, "types")) {

            $manager = \Drupal::service('flat_permissions.permissions_manager');

            $type_rules = $policy->types;
            foreach ($type_rules as $type_rule) {
                $mimetypes = property_exists($type_rule, "mimetypes") ? $type_rule->mimetypes : [];
                $filetypes = property_exists($type_rule, "filetypes") ? $type_rule->filetypes : [];
                $media_mimetype = $media->get('field_mime_type')->value;
                $media_filetype = $manager->mimeToType($media_mimetype);
                if (in_array($media_mimetype, $mimetypes) || in_array($media_filetype, $filetypes)) {
                    if (property_exists($type_rule, "roles")) {
                        $allowed_roles = $type_rule->roles;
                        $user_roles = $account->getRoles();
                        foreach ($user_roles as $user_role) {
                            if (in_array($user_role, $allowed_roles)) {
                                return AccessResult::allowed();
                            }
                        }
                    }
                    if (property_exists($type_rule, "users")) {
                        $allowed_users = $type_rule->users;
                        if (in_array($account->id(), $allowed_users)) {
                            return AccessResult::allowed();
                        }
                    }
                }
            }
        }

        // Finally, check if there are "files" rules that apply to specific media IDs
        if (property_exists($policy, "files")) {
            $files_rules = $policy->files;
            foreach ($files_rules as $file_rule) {
                // We've named them "file" rules but actually access to files is managed via the media entities,
                // so we work with the media IDs that link the files to the islandora_object nodes they belong to
                $media_ids = $file_rule->files;
                if (in_array($media->id(), $media_ids)) {
                    if (property_exists($file_rule, "roles")) {
                        $allowed_roles = $file_rule->roles;
                        $user_roles = $account->getRoles();
                        foreach ($user_roles as $user_role) {
                            if (in_array($user_role, $allowed_roles)) {
                                return AccessResult::allowed();
                            }
                        }
                    }
                    if (property_exists($file_rule, "users")) {
                        $allowed_users = $file_rule->users;
                        if (in_array($account->id(), $allowed_users)) {
                            return AccessResult::allowed();
                        }
                    }
                }
            }
        }

        // If there are no rules that match, access is denied
        return AccessResult::forbidden();
    }
}

function flat_permissions_write_access($nid, AccountInterface $account)
{
    $manager = \Drupal::service('flat_permissions.permissions_manager');
    $policy = $manager->fetchAccessPolicy($nid, 'write');

    $user_roles = $account->getRoles();

    // admin role always has write access
    foreach ($user_roles as $user_role) {
        if ($user_role == 'administrator') {
            return true;
        }
    }

    if (!$policy) {
        // If there's no policy in the hierarchy (shouldn't really be the case), deny access
        return false;
    }

    if (property_exists($policy, "roles")) {
        $allowed_roles = $policy->roles;
        foreach ($user_roles as $user_role) {
            if (in_array($user_role, $allowed_roles)) {
                return true;
            }
        }
    }

    if (property_exists($policy, "users")) {
        $allowed_users = $policy->users;
        if (in_array($account->id(), $allowed_users)) {
            return true;
        }
    }

    // If there are no rules that match, write access is denied
    return false;
}

function flat_permissions_node_access(NodeInterface $node, $operation, AccountInterface $account)
{
    $node_access_service = \Drupal::service('flat_permissions.node_access');

    $access = $node_access_service->userHasNodeAccess($node, $operation, $account);

    return $access ? AccessResult::allowed()->addCacheContexts(['ip', 'user']) : AccessResult::forbidden()->addCacheContexts(['ip', 'user']);
}

/**
 * Checks the visibility of a policy.
 *
 * @param mixed $policy The policy to check.
 * @return string Returns 'visible' if the policy has any visibility value set to visible, 'invisible' otherwise.
 */
function check_visibility($policy)
{

    $manager = \Drupal::service('flat_permissions.permissions_manager');

    if ($manager->objectAndPropertiesExist($policy, 'all->visibility')) {
        if ($policy->all->visibility == 'visible') {
            return 'visible';
        }
    } elseif ($manager->objectAndPropertiesExist($policy, 'types')) {
        foreach ($policy->types as $type_rule) {
            if ($manager->objectAndPropertiesExist($type_rule, 'visibility')) {
                if ($type_rule->visibility  == 'visible') {
                    return 'visible';
                }
            }
        }
    } elseif ($manager->objectAndPropertiesExist($policy, 'files')) {
        foreach ($policy->files as $file_rule) {
            if ($manager->objectAndPropertiesExist($file_rule, 'visibility')) {
                if ($file_rule->visibility  == 'visible') {
                    return 'visible';
                }
            }
        }
    }

    return 'invisible';
}

function flat_permissions_views_data_alter(array &$data)
{

    $data['node_field_data']['custom_node_access_filter'] = [
        'group' => 'Custom View Filters',
        'title' => t('FLAT Node Access Filter'),
        'filter' => [
            'title' => t('FLAT Node Access Filter'),
            'help' => t('Filter nodes based on FLAT access policies'),
            'field' => 'nid',
            'id' => 'custom_node_access_filter',
        ],
    ];
}

function flat_permissions_theme()
{
    return [
        'flat_permissions_read_policy' => [
            'variables' => ['data' => null],
            'template' => 'flat_permissions_read_policy',
        ],
        'flat_permissions_write_policy' => [
            'variables' => ['data' => null],
            'template' => 'flat_permissions_write_policy',
        ],
    ];
}
